<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>转载 on 氧气计算</title>
    <link>http://newoxygen.github.io/tags/%E8%BD%AC%E8%BD%BD/</link>
    <description>Recent content in 转载 on 氧气计算</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Nov 2015 14:40:48 +0800</lastBuildDate>
    <atom:link href="http://newoxygen.github.io/tags/%E8%BD%AC%E8%BD%BD/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>转-如何写好一篇好的技术博客</title>
      <link>http://newoxygen.github.io/post/%E8%BD%AC-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 24 Nov 2015 14:40:48 +0800</pubDate>
      
      <guid>http://newoxygen.github.io/post/%E8%BD%AC-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&#34;http://rock3.info/blog/2013/11/26/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/&#34;&gt;Rock3的Linux博客&lt;/a&gt;，挺早的一个博文了，最近自己写博客之后才关注到，我觉得写的很好，有借鉴的意义，我这里只做了适当排版和修正，另外建议大家看这篇博客的同时看一下知乎上的一个回答：[你有什么相见恨晚的知识想推荐给年轻人？][2]里面采铜的“四象限图”答案，了解什么是长半衰期，这样你就知道你应该写什么样的博客，看什么样的博客了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在工作过程中，发现对很多东西都一知半解，不是很透彻，到头来很容易模糊，如果有一篇好的技术博客予以总结，一来即使忘记了，回过头来再看，仍然能够从自己的思路中恢复；二来总结一下，还会发现一些潜在问题；三来，有利于大家交流技术。很多大公司都有自己的内部技术博客平台，写好自己的技术博客，对一个技术人员来说，也有一定的成就感。在网上查阅资料，经常可以看到一些技术博客，要么废话连篇、排版紊乱，要么代码占了篇幅的60%，有些甚至是错的，会让人产生误解。因此，在这总结一下一篇好的技术博客应该是怎样的，同时也规整自己的不良习惯。本篇博客纯属个人的一点想法，是个原则性的东西，切忌逐条对号入座啊。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本篇博客耗时2小时。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-带着明确的目的写博客:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;一、带着明确的目的写博客&lt;/h2&gt;

&lt;p&gt;经常看到这种博客，为了写博客而写博客。比如一篇介绍socket接口的使用方法的博客，罗列了一堆代码，凑上几句话：“首先&amp;hellip;，其次&amp;hellip;，最后&amp;hellip;”，就算OK。如果你的目的是“练习如何使用写博客的软件”，或者“罗列接口”，甚至“练习写作的方法”，那么可能达到了目的。但是我想，写一篇技术博客，首先是要明确该博客的目的，通常是学习一项技术、解决一个技术问题什么的，比如“学习Linux内存管理机制”，“解决kernel pannic的问题”，“打发时间”等。不是所有的的事情都要写一篇博客来记录，要有自己的判断什么东西值的写，什么东西不值的写。&lt;/p&gt;

&lt;h2 id=&#34;二-写自己的博客:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;二、写自己的博客&lt;/h2&gt;

&lt;p&gt;网上相互转载的帖子很多，一篇写的不错的博客经常会被转载，建议不要轻易转载别人的帖子，要写自己的博客。同样一个知识点，或者同样一个问题，你的理解和别人的理解的程度很可能是不一样的，如果轻易的看过以后转载了别人的博客，可能意味着一次自我学习或体会的机会的放弃。可能有人会说：”同样一个GFS的架构图，我画也是这样，他画也是这样，因为GFS就是这样设计的“，这里并不是要求任何一个细节都自己去做，而是要有自己的想法、自己的理解，比如GFS分层的原则是什么？为什么这样分层，分层的好处？如果我要是去做的话，我会怎么搞？写自己的博客可不是意味着不转载别人的，比如说我看了一篇博客，并且经过实验，却是与博客里面写的完全一致，不多也不少，如果要是自己的写的话，也会写的基本一样，那就没必要再花费时间自己写了。另外，以及纯粹记录性的博客，可以转载，比如“C语言运算符的优先级”，当然转载还是原创都不重要了。&lt;/p&gt;

&lt;p&gt;另外，把别人好的博客作为自己的原创，不但没品，而且自欺欺人。&lt;/p&gt;

&lt;p&gt;如果在博客中参考了别人的博客，可以在参考资料里面提及，如果是完全转载，也应注明转载出处。&lt;/p&gt;

&lt;h2 id=&#34;三-博客是总结-不是过程:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;三、博客是总结，不是过程&lt;/h2&gt;

&lt;p&gt;写博客有的时候是一个解决问题的过程。为了解决一个问题，今天采用了a方法，发现不行，明天采用了b方法，发现也不行，后天采用c方法，发现行了，那么最终的博客应该是在c方法解决问题后，开始写的。当然，前面的a，b方法，是需要做记录的，但只是博客的原始材料，而不是博客本身。在刚开始写博客时，我经常出现这种情况：对一个技术不清楚，想了解一下，就开一篇技术博客，边查资料边填写博客，结果基本上就是读、复制、粘贴、读、复制、粘贴的过程。最后落到自己手里也是空空如也，想起一句谚语：“狗熊掰梆子——掰一个丢一个”，在懊恼自己的缓存为什么这么少的同时，我也想是否是方法不对？后来我想过，要想掌握一项技术、知识，大概需要这样一个过程：实践遇到问题——理论学习问题——实践解决问题——理论总结问题。我想很多情况我是缺少了其中的三个部分，只有“理论学习问题”的过程。&lt;/p&gt;

&lt;p&gt;后来，我就改成按下列步骤写博客了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;碰到了问题，如果解决不了，而又比较有价值的话，就先记录下来，作为一篇博客的开篇。&lt;/li&gt;
&lt;li&gt;首先，先自己分析问题，基于已有的现象，思考，在笔记本上记录问题与可能的思路。&lt;/li&gt;
&lt;li&gt;其次，从外界获取经验或者知识，比如请教别人，google等，学习他们，在笔记本上记录关键点。&lt;/li&gt;
&lt;li&gt;然后，在实际中用学来的方法去解决问题，笔记本做好记录，要像水流过水渠一样流淌前面记录的思路。&lt;/li&gt;
&lt;li&gt;最后，拿过笔记本，将以上过程再总结成一篇博客。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，并不是所有博客都能够先从&amp;rdquo;实践遇到问题&amp;rdquo;开始，因为很多情况下都是先从书本理论开始学习的（这也就产生了一定的局限性，有时候你学的很好，反而陷入了固有的框架；有时你学的不好，显得自己更加无知）。这种情况，问题是需要自己总结出来的，比如ULK上会介绍中断和异常的处理机制，这包括中断的过程、CPU的工作、内核的工作、软中断的处理、tasklet等等，我们学习中断，不仅仅是一旦发生中断，Linux内核是按照什么流程去处理，而是要找到这么处理的原因，也就是解决了什么问题。有时，实践验证的成本过高，在有条件的前提下做吧。知识开始学习的时候，经常是只见树木，不见森林。俗话说：”孤木不成林“，弄上三五棵树，才会有”森林“的感觉。&lt;/p&gt;

&lt;h2 id=&#34;四-尽量拒绝三手技术:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;四、尽量拒绝三手技术&lt;/h2&gt;

&lt;p&gt;在实际学习或者工作中，一个问题不明白，那么就需要请教别人。如果能够从周围的高手、牛人那得到简单、直接的答复，那是最好的。如果不能，就需要自己在网上查找资料，可能一个问题，林林总总的在网上能搜出很多，选择看哪些就是个问题。尽量去选择原发性的材料，如果你在查gcc的一个编译选项是什么意思，可以使用man手册，如果还不清楚，就去gnu的官方站点去查，最好不要随便从某个转载的技术博客上获取。如果你要找x86平台CPU访问内存的方式，应该从Intel的官方站点去找CPU的资料，最好不要随便在网上找篇博客看了拉倒（起码应该先看官方材料）。&lt;/p&gt;

&lt;p&gt;别人的博客自然带有别人的理解，而这种理解可能带有一定的主观性，有时甚至是错误的，应该养成从原产地采购的习惯。如果哪天能够发明一项技术，那么这算一手技术；如果你在学习一项成熟的技术，那么该技术就属于二手技术了，如果你再从一个非源发性的地方去学习，那么很可能就是“三手技术”。当然，需要考虑实践成本，有时实在找不到源发性的材料，也不要太勉强自己了。另外，英文文章的水平整体高于国人的文章水平，应该尽量看英文文章。&lt;/p&gt;

&lt;h2 id=&#34;五-分清主次-落脚关键点:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;五、分清主次、落脚关键点&lt;/h2&gt;

&lt;p&gt;世界万事万物都有联系，凡是和本篇博客的主题有联系的问题，都在本篇博客中描述，是不现实的，也是没必要的。个人认为，一篇技术博客应该不超过两个主题，如果超过了，就应该拆分。但是次要问题可能会有不少，这些次要问题不一定都要解决掉，但一定要分清优先级，和主题关系比较大的，应首先解决，关系小的，应其次解决，甚至并不在本篇博客中解决。对于没有解决的问题，可以列在”遗留问题“中，对于在其他博客中讨论的问题，给予链接。&lt;/p&gt;

&lt;p&gt;根据自己的能力，耕耘到合适的层次。我将掌握一项技术划分为如下层次，在博客中通常应该达到第三个层次：
1. 听说过该技术，了解该技术解决什么问题；
2. 使用过该技术，熟悉该技术的使用方法；
3. 解构过该技术，熟悉该技术的架构、原理；
4. 贯通过该技术，将该技术与自己的已有知识完全融合，可以利用该技术架构解决其他问题。&lt;/p&gt;

&lt;h2 id=&#34;六-技术博客的风格:d620bc02c2e972e3f98edfd9f5850d6a&#34;&gt;六、技术博客的风格&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;技术博客不是论文，技术博客有其实用性。当然，也有将论文发在博客上的，比如技术博客的作者大部分应该是工程师，而不是学院派。一篇技术博客可以是小到的一个编程技巧，可以写该技巧的原理、实现方法、好处，但不要写前500后300年的历史介绍和展望未来。技术博客通常关心技术的实用性，而非技术背后理论的复杂性。技术博客也不应该过分求全责备，而把文章写的大而全，而应该追求小而精。&lt;/li&gt;
&lt;li&gt;技术博客应以陈述语气，个人感情色彩应该过滤掉，技术不是生活的全部。有人写技术博客，常喜欢加入自己的心情，“xxx让我好烦啊”、“xxx很难，我一直持续搞了两天没睡觉”，我个人拒绝这种“呻吟”的风格。&lt;/li&gt;
&lt;li&gt;忌罗列代码，代码是实现的过程，而不是原理，列代码是为了看清流程，而非为了列代码而列代码。我个人的习惯是尽量少列代码，如果能够使用校小的篇幅就能说明原理，绝不使用大篇幅的代码。但是如果简单的罗列代码能够一目了然，也绝不浪费过多的笔墨去描述过程。&lt;/li&gt;
&lt;li&gt;图片胜过文字，图片配文字比单纯的文字更加方便理解，甚至一张图就可以省略文字了，多画图，少写字是个原则。&lt;/li&gt;
&lt;li&gt;考虑时间成本，博客基本上是以时间换知识，因此需要越来越快，记录时间也很必要。&lt;/li&gt;
&lt;li&gt;列出遗留问题，以备以后解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[2]:&lt;a href=&#34;http://www.zhihu.com/question/22238159&#34;&gt;http://www.zhihu.com/question/22238159&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>转-Python的函数参数传递：传值？引用？</title>
      <link>http://newoxygen.github.io/post/%E8%BD%AC-Python%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9A%E4%BC%A0%E5%80%BC%EF%BC%9F%E5%BC%95%E7%94%A8%EF%BC%9F/</link>
      <pubDate>Fri, 20 Nov 2015 14:39:09 +0800</pubDate>
      
      <guid>http://newoxygen.github.io/post/%E8%BD%AC-Python%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9A%E4%BC%A0%E5%80%BC%EF%BC%9F%E5%BC%95%E7%94%A8%EF%BC%9F/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本来想自己谈一下Python函数实际参数的传递机制，但网上看了下有一篇文章写的挺好了，与我的理解相近就直接转载了，原文地址是&lt;a href=&#34;http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/&#34;&gt;《Python的函数参数传递：传值？引用？》&lt;/a&gt;，作者是[winterTTr][2]，稍微修改了一点不通或是自己感觉可以进一步理解的地方，以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想，这个标题或许是很多初学者的问题。尤其是像我这样的对C/C++比较熟悉，刚刚进入python殿堂的朋友们。C/C++的函数参数的传递方式根深蒂固的影响着我们的思维–引用？传值？究竟是那种呢？语言的特性决定了使用的方法，那么，现在我们来探究一下python的函数参数传递方式。&lt;/p&gt;

&lt;h2 id=&#34;对象vs变量:aa74a8d79dd81f1135cdfafa3350c174&#34;&gt;对象VS变量&lt;/h2&gt;

&lt;p&gt;在python中，对象有类型，变量是没有类型的，这正是python这种动态的语言特性，即不需要变量声明，这也是吸引着很多pythoner的一点。所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。所以，希望大家在看到一个python变量的时候，把变量和真正的内存对象分开。
&amp;gt;对象有类型，变量没有类型。
这样，很多问题就容易思考了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nfoo = 1       #变量nfoo指向一个int类型的对象，值为1
lstFoo = [1]   #变量lsrFoo指向一个list类型的对象，有一个元素lstFoo[0]，值为1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;可变-mutable-与不可变-immutable-对象:aa74a8d79dd81f1135cdfafa3350c174&#34;&gt;可变(mutable)与不可变(immutable)对象&lt;/h2&gt;

&lt;p&gt;对应于上一个概念，就必须引出另一个概念，这就是可变（mutable）对象与不可变（immutable）对象。对于python比较熟悉的人们都应该了解这个事实，在python中，strings, tuples, 和numbers是不可变的对象，而list,dict等则是可变的对象。那么，这些所谓的可变和不可变影响着什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#可变
nfoo = 1
nfoo = 2
#不可变
lstFoo = [1]
lstFoo[0] = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中第2行，内存中储存数值1的原始int对象不可改变，只是被『抛弃』，或者说『遗忘』，没有引用后被python的垃圾回收机制回收机制处理掉。然后变量nfoo指向一个新的int对象，值为2。&lt;/p&gt;

&lt;p&gt;代码第6行更改了list对象的第一个元素值，因为list是可变的，所以第一个原始变更为2。确切地说，不是变更，而是list的第一个元素指向了一个新的int型对象，就像刚刚说的不被引用的之前的int型对象会自动销毁。具体可以看下面的对比图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ooo.0o0.ooo/2015/11/20/564fe1aac8be4.jpg&#34; alt=&#34;内存示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的函数参数传递-传值-引用:aa74a8d79dd81f1135cdfafa3350c174&#34;&gt;Python的函数参数传递：传值？引用？&lt;/h2&gt;

&lt;p&gt;对于变量（与对象相对的概念），python函数参数传递可以理解为就是变量传值操作，用C++的方式理解，就是对void*赋值。如果这个变量的值不可变，我们看似就是引用，如果这个变量的值可变，我们看着像是在赋值。有点晕是吧，我们仍旧举个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不可变对象参数调用
def ChangeInt(a):
    a = 10
nfoo = 2 
ChangeInt(nfoo)
print nfoo #结果是2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时发生了什么，有一个int对象2，和指向它的变量nfoo，当传递给ChangeInt的时候，按照传值的方式，复制了变量nfoo的值，这样，a就是nfoo指向同一个Int对象了，函数中a=10的时候，发生什么？（还记得我上面讲到的那些概念么），int是不能更改的对象，于是，做了一个新的int对象，&lt;strong&gt;局部变量a&lt;/strong&gt;指向它（但是此时，被变量nfoo指向的对象，没有发生变化），于是在外面的感觉就是函数没有改变nfoo的值，看起来像C++中的传值方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可变对象参数调用
def ChangeList( a ):
    a[0] = 10
lstFoo = [2]
ChangeList(lstFoo )
print nfoo #结果是[10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当传递给ChangeList的时候，变量仍旧按照“传值”的方式，复制了变量lstFoo 的值，于是a和lstFoo 指向同一个对象，但是，list是可以改变的对象，对a[0]的操作，就是对lstFoo指向的对象的内容的操作，于是，这时的a[0] = 10，就是更改了lstFoo 指向的对象的第一个元素，所以，再次输出lstFoo 时，显示[10]，内容被改变了，看起来，像C++中的传引用。&lt;/p&gt;

&lt;p&gt;[2]:&lt;a href=&#34;http://winterttr.me/about/&#34;&gt;http://winterttr.me/about/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>